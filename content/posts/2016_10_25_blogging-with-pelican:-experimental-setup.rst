Blogging with Pelican: Experimental Setup
#########################################

:date: 2016-10-25 21:33
:tags: Pelican, Github Pages, Vagrant
:category:
:slug: blogging-with-pelican:-experimental-setup
:status: published

.. PELICAN_BEGIN_SUMMARY

Before getting serious into blogging with Pelican, there are two main concerns that must be solved: how to isolate it and all its dependencies from your current Python installation, and how to effectively manage version control.

.. PELICAN_END_SUMMARY 

For the first issue, the usual recommendation is to install Pelican in a new Python environment (e.g. using `virtualenv <https://virtualenv.pypa.io/en/stable/>`_)with and to always work using it. I totally hate environment-based setups. Do not ask me why, I have not found any reason but laziness.

Solving the second one can be a bit tricky. In every Pelican project you can distinguish up to 3 main "areas" of your workspace. The first one is the root folder itself, which contains the configuration and the theme you want to use. The second is the "contents" folder, which holds the source files that will generate your blog's posts and pages. And the third one is the "output" folder, which holds the actual HTML of the posts and pages, plus all the other goodies that must be uploaded in order to have a working web page. So, at the end of the day one can distinguish between two main group of files, the source ones and the generated ones. The problem here is that, in order to publish your blog using Github pages, you must commit only the contents of your "output" folder to the repository, but not the source ones (which you may want to commit somewhere else in order to track your changes!).

The customary solution for this consists in creating two different repositories, one for the source files and the other for publishing ("output" folder). The "output" repository is eventually included into the other as a submodule.

My setup
=========
As I have mentioned, I preferred to implement an experimental approach to the setup that allowed me to learn new things. First, I wanted to completely separate the source files of the project from the generated files, as well as to detach the editing process from the generation process. My solution has been to use a Virtual Machine (handled with `Vagrant <https://www.vagrantup.com/>`_) where the generation will take place. 

In brief, the root folder of the project (shared folder from the VM perspective) holds all source and configuration files and is associated to a branch called "source" of my Github pages repo. The first time I tell Vagrant to start the VM, it will install Pelican and all its needed packages. All the other times, it just regenerates the Pelican project structure into /home/vagrant/blog and creates symbolic links that point to the needed source files in the shared folder. This allows me to maintain the source file tree separated from the output and to set the folder structure I find more convenient (see the `source <https://github.com/victor-gil-sepulveda/victor-gil-sepulveda.github.io/tree/source>`_ branch to see what I am talking about). Also, it allows me to start Pelican's included HTTP server from the VM and mimic the access to a real remote web server. The output folder remains untracked though, it will get published in a different way (stay tuned!).

To summarize, this setup allows me to overcome some of the problems I have found using Octopress. First and foremost, it is all Python and I understand what is happening in the background. Also, the incredibly complex file tree generated by Octopress gets seamlessly simplified and the folder structure makes sense to me. Maybe not to the rest of the world, but in this case I will be the only one working here, isn't it?. Finally, having the source files are totally separated from the generation process allows a safer workflow. I think that now it is highly improbable that my files get lost due to Pelican updates, as it happened with Octopress. 


