<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>The lost library of Agraphur</title><link>https://victor-gil-sepulveda.github.io/</link><description>Pieces from a whole</description><lastBuildDate>Wed, 09 Nov 2016 11:06:00 +0100</lastBuildDate><item><title>Blogging with Pelican: The Management Script</title><link>https://victor-gil-sepulveda.github.io/blogging-with-pelican:-the-management-script.html</link><description>
&lt;p&gt;At some point, when you start to do serious blogging, automation is needed. To be honest, this is not my case right now (I just wrote three posts so far in my new blog incarnation, which does not look too serious), but it is always fun to try new things.&lt;/p&gt;

&lt;p&gt;The main goal here is to create a Python script that helps us performing some common operations that can be identified as part of the blogging work flow, like:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Creating new empty pages and posts (&lt;em&gt;new_page&lt;/em&gt;, &lt;em&gt;new_post&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Starting the development web server (&lt;em&gt;serve&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Cleaning the symlink structure (&lt;em&gt;remove_symlinks&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Publishing changes to Github (&lt;em&gt;publish&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the command line interface parsing, I wanted to try &lt;a class="reference external" href="https://github.com/willyg302/clip.py"&gt;clip.py&lt;/a&gt; as an alternative to the well-known &lt;em&gt;optparse&lt;/em&gt; module. This tiny package allows to define the commands, arguments and options of your script in a declarative way by using Python decorators.&lt;/p&gt;
&lt;p&gt;You can find the complete script &lt;a class="reference external" href="https://github.com/victor-gil-sepulveda/victor-gil-sepulveda.github.io/blob/source/scripts/local/manage.py"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="creating-new-empty-pages-and-posts"&gt;
&lt;h2&gt;Creating new empty pages and posts&lt;/h2&gt;
&lt;p&gt;The idea (and part of the code) comes from &lt;a class="reference external" href="http://nafiulis.me/making-a-static-blog-with-pelican.html"&gt;this page&lt;/a&gt;. Basically, this command uses two reStructured Text templates, one for the &lt;a class="reference external" href="https://github.com/victor-gil-sepulveda/victor-gil-sepulveda.github.io/blob/source/scripts/local/new_page.template"&gt;pages&lt;/a&gt; and other for the &lt;a class="reference external" href="https://github.com/victor-gil-sepulveda/victor-gil-sepulveda.github.io/blob/source/scripts/local/new_post.template"&gt;posts&lt;/a&gt;, and populates the title, date etc. with proper values. Then it writes them to the /content/pages or content/posts folders. This is exactly the same that Octopress did, but with less magic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="starting-the-development-web-server"&gt;
&lt;h2&gt;Starting the development web server&lt;/h2&gt;
&lt;p&gt;I also needed a way to perform quick tests with the new posts. This involves to start the VM and start the development server. In order to manage the VM with vagrant from the script I use the handy &lt;a class="reference external" href="https://github.com/todddeluca/python-vagrant"&gt;python-vagrant&lt;/a&gt; Python module. Once the VM is up, the script calls an inner VM bash script through an ssh command.&lt;/p&gt;
&lt;p&gt;The problem with the development server is that it cannot recover from errors. If an error happens, one has to enter the VM, kill the process and restart the server (if needed).&lt;/p&gt;
&lt;p&gt;This command does not automatically stop the VM.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cleaning-the-symlink-structure"&gt;
&lt;h2&gt;Cleaning the symlink structure&lt;/h2&gt;
&lt;p&gt;A script is executed whenever a vagrant up event happens, in order to recreate the blog workspace. This generates tones of symbolic links in the host, that can become burden if using &lt;em&gt;git&lt;/em&gt; for version control, as it treats links as regular files. Before issuing a git status command, it is convenient to remove this symbolic links.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="publishing-changes-to-github"&gt;
&lt;h2&gt;Publishing changes to Github&lt;/h2&gt;
&lt;p&gt;Every time I want to publish the changes I have to start the virtual machine, generate the publish version of the blog and upload it to the repository. The script starts the VM using &lt;a class="reference external" href="https://github.com/todddeluca/python-vagrant"&gt;python-vagrant&lt;/a&gt;, then it issues an ssh command that runs a script in the host. This script  is in charge of generating the files and moving the results to the shared folder. Finally it uses &lt;a class="reference external" href="https://github.com/davisp/ghp-import"&gt;ghp-import&lt;/a&gt; to move the newly created files to the master branch of the repository in Github Pages so that they get published.&lt;/p&gt;
&lt;p&gt;Again, the script does not stop the VM, so in case halting the VM it is needed, it must be done manually.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="adding-simple-bash-completion"&gt;
&lt;h2&gt;Adding simple bash completion&lt;/h2&gt;
&lt;p&gt;It is very cool to have a script that allows you to automate tasks, but it is even cooler if you do not have to write too much in order to use it. That is why I tried to add a simple autocompletion feature to the script.&lt;/p&gt;
&lt;p&gt;I have investigated how this kind of autocompletion could be done with Python and ... well ... it looks like it cannot be done. At least directly. But it is quite easy to add 1st level autocompletion to a Bash script. The solution is then to create a Bash script wrapper for the Python script. Unnecessarily complex? yes, but this is another of these things I just do for the sake of learning.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.gnu.org/software/bash/manual/bashref.html#Programmable-Completion-Builtins"&gt;This page&lt;/a&gt; explains how to use the autocompletion mechanisms of Bash. Basically, one has to register the words to be used for autocompletion by adding this line to your &lt;em&gt;.bashrc&lt;/em&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;complete&lt;/span&gt; -W &lt;span class="s2"&gt;&amp;quot;new_page new_post publish remove_symlinks serve&amp;quot;&lt;/span&gt; blog_manage
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously the &lt;em&gt;blog_manage&lt;/em&gt; bash script is already in our PATH.&lt;/p&gt;
&lt;p&gt;Take care!&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">VÃ­ctor A. Gil</dc:creator><pubDate>Wed, 09 Nov 2016 11:06:00 +0100</pubDate><guid isPermaLink="false">tag:victor-gil-sepulveda.github.io,2016-11-09:blogging-with-pelican:-the-management-script.html</guid></item><item><title>How to run VMD 1.9.3 beta 4 for Linux</title><link>https://victor-gil-sepulveda.github.io/how-to-run-vmd-1.9.3-beta-4-for-linux.html</link><description>
&lt;p&gt;&lt;a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd/"&gt;VMD&lt;/a&gt; is, without any doubt, one of the most used free molecular visualizers out there. The only problem this software has is that the guys of the T&amp;amp;CB group at the university of Illinois do not update it very often. We must be happy then that a new beta version has landed the last 28th of October.&lt;/p&gt;

&lt;p&gt;The problem of beta versions is that, well, they are beta. Beta versions are considered to be unstable and contain unknown bugs that users can discover and report. Isn't it fun?&lt;/p&gt;
&lt;p&gt;In this case, a minor error avoids some users from enjoying this marvelous software. In order to install it in a 64 bit Linux machine, just download the proper tar.gz file (e.g. &lt;em&gt;LINUX_64OpenGL,CUDA,OptiX,OSPRay&lt;/em&gt;), uncompress it wherever you want, enter the folder and run ./configure with the options you want (running it without options will print them). To be honest, I do not really know if the options you choose will modify the final result. This is an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; tar -xvf vmd-1.9.3beta4.bin.LINUXAMD64-CUDA8-OptiX4-OSPRay111.opengl.tar.gz
&amp;gt; &lt;span class="nb"&gt;cd&lt;/span&gt; vmd-1.9.3beta4/
&amp;gt; ./configure LINUXAMD64 OPENGL LIBTACHYON TCL PYTHON PTHREADS NUMPY
&amp;gt; &lt;span class="nb"&gt;cd&lt;/span&gt; src
&amp;gt; sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and we are done! Just run &lt;code class="bash"&gt;vmd&lt;/code&gt; in a console emulator and you can start enjo... wait! what happened!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; vmd
/usr/local/bin/vmd: 331: /usr/local/bin/vmd: Syntax error: &lt;span class="s2"&gt;&amp;quot;else&amp;quot;&lt;/span&gt; unexpected &lt;span class="o"&gt;(&lt;/span&gt;expecting &lt;span class="s2"&gt;&amp;quot;then&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ok, so this is one of these unknown bugs I mentioned before. However, we are lucky that this one is quite simple. A quick inspection of the vmd launcher script (you can find the file using &lt;code class="bash"&gt;which vmd&lt;/code&gt;) reveals that a &lt;code class="bash"&gt;&lt;span class="k"&gt;then&lt;/span&gt;&lt;/code&gt; statement is missing (after line 329):&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;323
324
325
326
327
328
329
330
331
332
333&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Test to see if a 64-bit version of VMD exists&lt;/span&gt;
&lt;span class="c1"&gt;# in the installation directory, and use the 64-bit&lt;/span&gt;
&lt;span class="c1"&gt;# version if it is there.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;VMDDIR&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;vmdbasename&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;_LINUXPPC64LE&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;LINUXPPC64LE
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;VMDDIR&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;vmdbasename&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;_OPENPOWER&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
    &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;OPENPOWER
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;SUMMIT
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Just add the missing &lt;code class="bash"&gt;&lt;span class="k"&gt;then&lt;/span&gt;&lt;/code&gt; statement, and it will finally work.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;323
324
325
326
327
328
329
330
331
332
333
334&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Test to see if a 64-bit version of VMD exists&lt;/span&gt;
&lt;span class="c1"&gt;# in the installation directory, and use the 64-bit&lt;/span&gt;
&lt;span class="c1"&gt;# version if it is there.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;VMDDIR&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;vmdbasename&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;_LINUXPPC64LE&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;LINUXPPC64LE
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;VMDDIR&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;vmdbasename&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;_OPENPOWER&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="k"&gt;then&lt;/span&gt;
&lt;/span&gt;    &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;OPENPOWER
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;SUMMIT
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Hope it helps!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">VÃ­ctor A. Gil</dc:creator><pubDate>Tue, 08 Nov 2016 20:59:00 +0100</pubDate><guid isPermaLink="false">tag:victor-gil-sepulveda.github.io,2016-11-08:how-to-run-vmd-1.9.3-beta-4-for-linux.html</guid></item><item><title>Blogging with Pelican: Experimental Setup</title><link>https://victor-gil-sepulveda.github.io/blogging-with-pelican:-experimental-setup.html</link><description>
&lt;p&gt;Before getting serious into blogging with Pelican, there are two main concerns that must be solved: how to isolate it and all its dependencies from your current Python installation, and how to effectively manage version control.&lt;/p&gt;

&lt;p&gt;For the first issue, the usual recommendation is to install Pelican in a new Python environment (e.g. using &lt;a class="reference external" href="https://virtualenv.pypa.io/en/stable/"&gt;virtualenv&lt;/a&gt;)with and to always work using it. I totally hate environment-based setups. Do not ask me why, I have not found any reason but laziness.&lt;/p&gt;
&lt;p&gt;Solving the second one can be a bit tricky. In every Pelican project you can distinguish up to 3 main &amp;quot;areas&amp;quot; of your workspace. The first one is the root folder itself, which contains the configuration and the theme you want to use. The second is the &amp;quot;contents&amp;quot; folder, which holds the source files that will generate your blog's posts and pages. And the third one is the &amp;quot;output&amp;quot; folder, which holds the actual HTML of the posts and pages, plus all the other goodies that must be uploaded in order to have a working web page. So, at the end of the day one can distinguish between two main group of files, the source ones and the generated ones. The problem here is that, in order to publish your blog using Github pages, you must commit only the contents of your &amp;quot;output&amp;quot; folder to the repository, but not the source ones (which you may want to commit somewhere else in order to track your changes!).&lt;/p&gt;
&lt;p&gt;The customary solution for this consists in creating two different repositories, one for the source files and the other for publishing (&amp;quot;output&amp;quot; folder). The &amp;quot;output&amp;quot; repository is eventually included into the other as a submodule.&lt;/p&gt;
&lt;div class="section" id="my-setup"&gt;
&lt;h2&gt;My setup&lt;/h2&gt;
&lt;p&gt;As I have mentioned, I preferred to implement an experimental approach to the setup that allowed me to learn new things. First, I wanted to completely separate the source files of the project from the generated files, as well as to detach the editing process from the generation process. My solution has been to use a Virtual Machine (handled with &lt;a class="reference external" href="https://www.vagrantup.com/"&gt;Vagrant&lt;/a&gt;) where the generation will take place.&lt;/p&gt;
&lt;p&gt;In brief, the root folder of the project (shared folder from the VM perspective) holds all source and configuration files and is associated to a branch called &amp;quot;source&amp;quot; of my Github pages repo. The first time I tell Vagrant to start the VM, it will install Pelican and all its needed packages. All the other times, it just regenerates the Pelican project structure into /home/vagrant/blog and creates symbolic links that point to the needed source files in the shared folder. This allows me to maintain the source file tree separated from the output and to set the folder structure I find more convenient (see the &lt;a class="reference external" href="https://github.com/victor-gil-sepulveda/victor-gil-sepulveda.github.io/tree/source"&gt;source&lt;/a&gt; branch to see what I am talking about). Also, it allows me to start Pelican's included HTTP server from the VM and mimic the access to a real remote web server. The output folder remains untracked though, it will get published in a different way (stay tuned!).&lt;/p&gt;
&lt;p&gt;To summarize, this setup allows me to overcome some of the problems I have found using Octopress. First and foremost, it is all Python and I understand what is happening in the background. Also, the incredibly complex file tree generated by Octopress gets seamlessly simplified and the folder structure makes sense to me. Maybe not to the rest of the world, but in this case I will be the only one working here, isn't it?. Finally, having the source files are totally separated from the generation process allows a safer workflow. I think that now it is highly improbable that my files get lost due to Pelican updates, as it happened with Octopress.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">VÃ­ctor A. Gil</dc:creator><pubDate>Tue, 25 Oct 2016 21:33:00 +0200</pubDate><guid isPermaLink="false">tag:victor-gil-sepulveda.github.io,2016-10-25:blogging-with-pelican:-experimental-setup.html</guid><category>Pelican</category><category>Github Pages</category><category>Vagrant</category></item><item><title>Blogging with Pelican: First Impressions</title><link>https://victor-gil-sepulveda.github.io/theres_a_new_bloger.html</link><description>&lt;div class="section" id="there-s-a-new-blogger-in-town"&gt;
&lt;h2&gt;There's a new blogger in town!&lt;/h2&gt;
&lt;p&gt;It was the year 2014. I was young and inexperienced &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt;, and I wanted to start a web log. At that time I was coursing a PhD, which is a well known way of being poor for the rest of your life &lt;a class="footnote-reference" href="#id4" id="id2"&gt;[2]&lt;/a&gt;, reason why I looked for a free hosting solution where my (obviously static) blog would reside. The winner from my not-so-impressive list was Github pages.&lt;/p&gt;
&lt;p&gt;Github pages can process &lt;a class="reference external" href="https://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; blogs out of the box, which looked like a very fancy feature, but Jekyll did not look so fancy to me. It was written in Ruby and I did not had patience to learn that language. But there was still another option: &lt;a class="reference external" href="http://octopress.org/"&gt;Octopress&lt;/a&gt;. They were claiming that it was a very automatized Jekyll blog generation tool. I believed it. And this was my first and last mistake as blogger.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="my-experience-with-octopress"&gt;
&lt;h2&gt;My experience with Octopress&lt;/h2&gt;
&lt;p&gt;As you may have already guessed from the previous paragraph, my experience with Octopress was not that good. First and foremost, all the magic it was performing made me feel uncomfortable. But maube the most important thing is that it was cluttering my blog workspace with tones of folders and configuration files. And as I did not read the code, I did not have any clue of how the generation process worked.&lt;/p&gt;
&lt;p&gt;In more than two years I only published a post. And its source file just disappeared one of those times I had to reinstall Octopress. I also wrote a lot of other proto-posts in &lt;em&gt;txt&lt;/em&gt; files. All were lost the last time I had to change the &lt;em&gt;OS&lt;/em&gt;. So, in conclusion, Octopress was not fostering my productivity at all.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="long-live-pelican"&gt;
&lt;h2&gt;Long live Pelican!&lt;/h2&gt;
&lt;p&gt;Recently, and thanks to several conversations with professional recruiters, I have discovered that my CV is too difficult to understand. It is understandable: since they receive tones of CVs per day and only have some minutes to spend with every one, a too complex CV is the first step to failure. Besides, my CV has two added handicaps: first,  it is an &amp;quot;academic CV&amp;quot;, which means it is long and full of details that are of no interest to regular companies. Second, I have worked as a &lt;a class="reference external" href="http://www.rse.ac.uk/who.html"&gt;Research Software Engineer&lt;/a&gt; these last 9 years, which is a rare and difficult to explain role. This meant I had to devise a better way to present myself to prospective employers. What about trying with a blog again? Why not?&lt;/p&gt;
&lt;p&gt;Again, I focused on static blog generators, but this time I decided I wanted it to be in a language I already mastered: Python. There are many choices (ej. &lt;a class="reference external" href="https://getnikola.com/"&gt;Nikola&lt;/a&gt;, &lt;a class="reference external" href="http://hyde.github.io/"&gt;Hyde&lt;/a&gt;), and I just picked the one that looked to have the smaller codebase: &lt;a class="reference external" href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Starting a blog with Pelican is incredibly easy. Just use the &amp;quot;quickstart&amp;quot; script and download a theme. You will have a complete blog in a matter of minutes. And, also very important, you will not end with cluttered workspace: in its simplest form, Pelican just needs a contents folder and a couple of configuration scripts. Which are written in Python too. Delightful.&lt;/p&gt;

&lt;p&gt;There are only two drawbacks of Pelican as far as I have seen:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The documentation is too brief and does not cover all the features in detail. It can become very difficult to obtain information about how to extend Pelican with plugins or about how to use some configuration options (which can give you the impression that some of them are buggy). You will end learning by example, thanks to the several other Pelican users that have documented their efforts.&lt;/li&gt;
&lt;li&gt;It does not have a managing system for simple and repetitive tasks like creating posts, which other static generators like Octopress have.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I suppose the first issue will improve over time, and about the second one ... well, you can do it yourself. At the end of the day that is&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Now I am older and yet inexperienced.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;You gain extra poverty points if you do it in Spain!&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">VÃ­ctor A. Gil</dc:creator><pubDate>Mon, 17 Oct 2016 19:30:00 +0200</pubDate><guid isPermaLink="false">tag:victor-gil-sepulveda.github.io,2016-10-17:theres_a_new_bloger.html</guid><category>Pelican</category></item></channel></rss>